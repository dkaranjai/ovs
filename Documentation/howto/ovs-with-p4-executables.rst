..
      Licensed under the Apache License, Version 2.0 (the "License"); you may
      not use this file except in compliance with the License. You may obtain
      a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
      WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
      License for the specific language governing permissions and limitations
      under the License.

      Convention for heading levels in Open vSwitch documentation:

      =======  Heading 0 (reserved for the title in a document)
      -------  Heading 1
      ~~~~~~~  Heading 2
      +++++++  Heading 3
      '''''''  Heading 4

      Avoid deeper levels because they do not render well.

==========================================================
Usage of Open vSwitch generated executables for P4 support
==========================================================

This document describes how to use executables generated by Open vSwitch
for supporting P4 programs.

- For code clone and build instructions refer to ``p4proto/p4rt/README``.

Prerequisites
-------------

Before using executables generated by OvS for P4 programming, user should
be having a valid P4 file and generated dependent files using P4 compiler
for the specific target.

Dependent generated files for a sample.p4 file::

    $ sample.conf, p4info.txt, bf-rt.json, pipe/context.json, pipe/sample.spec


ovs_pipeline_builder executable
-------------------------------

ovs_pipeline_builder is an executable generated when OvS is built and this
executable is used to generate a protobuf based bin file.
This pb.bin contains information of bfrt-config, context and config which are
extracted from sample.conf which is genrated via p4c compiler as mentioned
above.

Generate ``pb.bin``::

    $ ovs_pipeline_builder --p4c_conf_file=<path-to-input-sample-file.conf> \
        --bf_pipeline_config_binary_file=<path-to-output-file.pb.bin>
    $ Example: \
        ovs_pipeline_builder --p4c_conf_file=/home/mydir/sample.conf \
            --bf_pipeline_config_binary_file=/home/mydir/sample.pb.bin

.. important::

    Here we need to execute this command from the parent directory of
    relative paths mentioned in bfrt-config/context/config parameters
    of sample.conf


ovs-p4ctl executable
--------------------

ovs-p4ctl is an executable generated when OvS is built and this executable
is an gRPC client which connects to gRPC server running in OvS for enabling
p4runtime capabilities.

Each CLI command connects to gRPC ports opened by server, send a protobuf based
message. Refer to p4runtime.proto for more details on type of messages and
services that are available for a p4runtime client.

1. Set a forwarding pipeline::

    $ ovs-p4ctl set-pipe SWITCH PROGRAM P4INFO
    $ Example: ovs-p4ctl set-pipe br0 <path>/sample.pb.bin <path>/p4info.txt

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``PROGRAM``: Refers to protobuf binary file generated by
    ovs_pipeline_builder executable and P4 program's configuration file.
    ``P4INFO``: Refers to P4Info.txt file generated by p4c compiler
    for a P4 program.

2. Get a forwarding pipeline::

    $ ovs-p4ctl get-pipe SWITCH
    $ Example: ovs-p4ctl set-pipe br0

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.

3. Add a rule for a table into the forwarding pipeline::

    $ ovs-p4ctl add-entry SWITCH TABLE FLOW
    $ Example:
    ovs-p4ctl add-entry br0 ipv4_host "dst_ip=1.1.1.1,action=send(10)"

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``TABLE``: Refers to table_name present in p4info.txt file.
    ``FLOW``: Refers to parameters for a the above mentioned TABLE
    match_filed_key=value action=action_name(value)

4. Delete a rule for a table from the forwarding pipeline::

    $ ovs-p4ctl del-entry SWITCH TABLE KEY
    $ Example: ovs-p4ctl del-entry br0 ipv4_host "dst_ip=1.1.1.1"

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``TABLE``: Refers to table_name present in p4info.txt file.
    ``KEY``: Refers to match_filed_key parameter of the above mentioned
    TABLE match_filed_key=value

5. Get programmed rule from the forwarding pipeline [Future Implementation]::

    $ ovs-p4ctl dump-entries SWITCH [TABLE]
    $ Example: ovs-p4ctl dump-entries br0 ipv4_host

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``TABLE``: Refers to table_name present in p4info.txt file.
    This is an optional field for get/dump command.

6. Set a default entry for a table into the forwarding pipeline ::

    $ ovs-p4ctl set-default-entry SWITCH TABLE ACTION
    $ Example: ovs-p4ctl set-default-entry br0 ipv4_host "send(10)"

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``TABLE``: Refers to table_name present in p4info.txt file.
    ``ACTION``: Refers to action parameter of the above mentioned TABLE
    action_name(value)

7. Get a default entry for a table from the forwarding pipeline [Future Implementation]::

    $ ovs-p4ctl get-default-entry SWITCH TABLE
    $ Example: ovs-p4ctl get-default-entry br0 ipv4_host

  .. note::

    ``SWITCH``: Referes to the bridge name, which maps to device name
    internally.
    ``TABLE``: Refers to table_name present in p4info.txt file.


gnmi_cli executable
-------------------

gnmi_cli is an executable generated when OvS is built and this executable
is an gRPC client which connects to gRPC server running in OvS for enabling
gNMI/openconfig capabilities.

Each CLI command connects to gRPC ports opened by server, send a protobuf based
message. Refer to gnmi.proto and gnmi_ext.proto for more details on type of
messages and services that are available for a gNMI client.

Each CLI format should be inline with the YANG parser available in server which
is a tree based hierarchy. In P4 based OvS, we are having Interfaces as
root-node and followed by device type. Each device can hold muiltiple
ports, where port-name is acting as a KEY.
For Each port, we can have config parameters and state parameters.
We can execute SET command for config params and GET command for the
previously configured CONFIG params.

1) Set atrributes for a vhost port::

    $ gnmi-cli set PARAMS
    $ Example:
    gnmi-cli set "device:virtual-device,name:net_vhost0,device-type:VIRTIO_NET"
    gnmi-cli set "device:virtual-device,name:net_vhost0,port-type:LINK"
    gnmi-cli set "device:virtual-device,name:net_vhost0,host:host1,
                  device-type:VIRTIO_NET,queues:1,
                  socket-path:/tmp/vhost-user-0,port-type:LINK"
    gnmi-cli set "device:virtual-device,name:net_vhost0,host:host1,
                  device-type:VIRTIO_NET,queues:1,
                  pipeline-name:pipe,mempool-name:MEMPOOL0,mtu:2000,
                  socket-path:/tmp/vhost-user-0,port-type:LINK"

  .. note::

    ``PARAMS``: These params are key:value pairs. Here virtual-device is a
    sub-node which holds multiple ports like net_vhost0, net_vhost1,... and
    each port accepts multiple config params. These config params are again a
    key:value pair, either can be passed in single CLI command or multiple
    CLI commands.
    name: can take values defined in chassis config file. Refer to file
    dpdk_port_config.pb.txt for port names.
    host: can be any string.
    queues: number of queues required by backend.
    socket-path: socket path required by backend.
    port-type: can take values defined in common.proto. Supported value is LINK.
    device-type: can take values defined in common.proto. Supported values is
    VIRTIO_NET.
    pipeline-name: this is a non-mandatory parameter, if not specifically
    configured by the user it is considered as value `pipe`
    mempool-name: this is a non-mandatory parameter, if not specifically
    configured by the user it is considered as value `MEMPOOL0`
    mtu: this is a non-mandatory parameter, if not specifically configured
    by the user it is considered as value `1500`


2) Get attributes for vhost port::

    $ gnmi-cli get PARAMS
    $ Example:
    gnmi-cli get "device:virtual-device,name:net_vhost0,device-type"
    gnmi-cli get "device:virtual-device,name:net_vhost0,port-type"

  .. note::

    ``PARAMS``: These params are key:value pairs. Here virtual-device is a
    sub-node which holds multiple ports like net_vhost0, net_vhost1,... Pass
    the key name for whose value need to be fetched. Each get can take ONLY
    one key, and fetches value for that previously configured KEY.

.. important::
  If grpc connection to server fails, export GRPC_TRACE=all and check if any
  proxy errors are encountered. If Yes, then configure localhost as an entry in
  NO_PROXY environmental variable (append localhost if NO_PROXY is already
  configured).

  Example: export NO_PROXY=localhost,127.0.0.1

3) Set atrributes for tap ports::

    $ gnmi-cli set PARAMS
    $ Example:
    gnmi-cli set "device:virtual-device,name:TAP0,mtu:1500,port-type:TAP"
    gnmi-cli set "device:virtual-device,name:TAP1,pipeline-name:pipe,
                  mempool-name:MEMPOOL0,mtu:1500,port-type:TAP"

  .. note::

    ``PARAMS``: These params are key:value pairs. Here virtual-device is a
    sub-node which holds multiple ports like TAP0, TAP1,... and
    each port accepts multiple config params. These config params are again a
    key:value pair, either can be passed in single CLI command or multiple
    CLI commands.
    name: can take values defined in chassis config file. Refer to file
    dpdk_port_config.pb.txt for port names.
    port-type: can take values defined in common.proto. Supported value is
    TAP.
    mtu: this is a mandatory parameter, to be specified by user.
    pipeline-name: this is a non-mandatory parameter, if not specifically
    configured by the user it is considered as value `pipe`
    mempool-name: this is a non-mandatory parameter, if not specifically
    configured by the user it is considered as value `MEMPOOL0`

4) Get attributes for tap ports::

    $ gnmi-cli get PARAMS
    $ Example:
    gnmi-cli get "device:virtual-device,name:TAP0,port-type"
    gnmi-cli get "device:virtual-device,name:TAP1,pipeline-name"

  .. note::

    ``PARAMS``: These params are key:value pairs. Here virtual-device is a
    sub-node which holds multiple ports like net_vhost0, net_vhost1,... Pass
    the key name for whose value need to be fetched. Each get can take ONLY
    one key, and fetches value for that previously configured KEY.

5) VIRTIO-NET Device Hot plug for DPDK Target::

    This feature will allow the user to hotplug the vhost-user ports to the running VM.
    To hotplug the vhost-user port to qemu based VM, add monitor option when instantiating
    qemu based VM and specify the telnet port and ip for qemu monitor socket.
    Example of qemu command:
      qemu-system-x86_64 -enable-kvm -smp 4 -m 1024M \
      -boot c -cpu host -enable-kvm -nographic \
      -L /root/pc-bios -name VM1_TAP_DEV \
      -hda /root/VM/vm1.qcow2 \
      -object memory-backend-file,id=mem,size=1024M,mem-path=/dev/hugepages,share=on \
      -mem-prealloc \
      -numa node,memdev=mem \
      -monitor telnet::6555,server,nowait \
      -serial telnet::6551,server &

    Boot up the VM and login to console using telnet port (in the above example port 6551).
    This VM will have 1 default port. To hotplug the vhost-user port, issue the following
    gnmi-cli command:

      $ gnmi-cli set PARAMS
      $ Command to hotplug add the port. Example:
      $ gnmi-cli set "device:virtual-device,name:net_vhost0,hotplug:add,
                      qemu-socket-ip:127.0.0.1,qemu-socket-port:6555,
                      qemu-vm-mac:00:e8:ca:11:aa:01,qemu-vm-netdev-id:netdev0,
                      qemu-vm-chardev-id:char1,native-socket-path:/tmp/intf/vhost-user-0,
                      qemu-vm-device-id:dev0"
      $ Command to hotplug delete the port. Example:
      $ gnmi-cli set "device:virtual-device,name:net_vhost0,hotplug:del"
.. note::

   ``PARAMS``: These params are key:value pairs. Here virtual-device is a
    sub-node which holds multiple ports like net_vhost0, net_vhost1,... and
    each port accepts multiple config params. These config params are again a
    key:value pair, either can be passed in single CLI command or multiple
    CLI commands.
    name: can take values defined in chassis config file. Refer to file
    dpdk_port_config.pb.txt for port names.
    hotplug: Specify if the device needs to be hotplugged (add/ADD for hotplug
    add, del/DEL for hotplug delete)
    qemu-socket-ip: Specify IP of the host where qemu monitor socket resides.
    qemu-socket-port: Specify qemu monitor socket port
    qemu-vm_mac: Specify MAC address for port hotplugged to qemu VM
    qemu-vm_netdev-id: Specify netdev ID for port hotplugged to qemu VM
    qemu-vm_chardev-id: Specify chardev ID for port hotplugged to qemu VM
    native-socket-path: Specify the native path for vhost-user socket on host
    qemu-vm-device-id: Specify device ID for port hotplugged to qemu VM

   Port can be hotplug added once and hotplug deleted once. Re-adding or
   deleting the port is not supported in older qemu versions due to qemu bug
   reporting false duplicate IDs. This bug is fixed in qemu version 6.1.0 and
   re-adding and re-deleting the hotplug port is supported from qemu version
   6.1.0

